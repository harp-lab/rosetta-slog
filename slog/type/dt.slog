
; pure first order dependent type ('lambda~LF)
; based on advance topic in type and programming language
; Charpter 2.2

; term
; var
(var "x")
; abstraction
('lambda~ "x" (type "T") (var "x"))
; application
(app ('lambda~ "x" (var "x")) (var "y"))

; term helper predicate
(term-not-'lambda~ ?(var x))
(term-not-'lambda~ ?(app func arg))

; types
; type/family var
(type "T")
; dependent product type
('Pi~ "x" (type "T") (type "T"))
; type family application
(t-app (type "T") (var "x"))

; kind
; kind of proper type
('star~)
; kind of type family
('Pi~ "x" (type "T") ('star~))

; context
('mt~)
(ctx (term-bind "x" (type "T"))
    (ctx (type-bind (type "X") ('star~))
        ('mt~)))

; ---------------------------------------------
; typing rule helper functions

; predicate if binding is in an context
('in~ ?(ctx bind rest) bind)
[('in~ res bind1) --> ('in~ ?(ctx bind res) bind1)]

; free variable
(free-var-huh ?(check-fv x (var x)) ('top~))
[(=/= x y) --> (free-var-huh ?(check-fv x (var y)) ('bot~))]

(free-var-huh ?(check-fv x ('lambda~ x T body)) ('bot~))
[(free-var-huh ?(check-fv x ('lambda~ y T body)) ('top~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x body) ('top~))
    (free-var-huh !(check-fv x T) ('top~))]
[(free-var-huh ?(check-fv x ('lambda~ y T body)) ('bot~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x body) ('bot~))]
[(free-var-huh ?(check-fv x ('lambda~ y T body)) ('bot~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x T) ('bot~))]

[(free-var-huh ?(check-fv x (app func arg)) ('top~)) <--
    (free-var-huh !(check-fv x func) ('top~))
    (free-var-huh !(check-fv x arg) ('top~))]
[(free-var-huh ?(check-fv x (app func arg)) ('bot~)) <--
    (free-var-huh !(check-fv x func) ('bot~))]
[(free-var-huh ?(check-fv x (app func arg)) ('bot~)) <--
    (free-var-huh !(check-fv x arg) ('bot~))]

(free-var-huh ?(check-fv x (type T-name)) ('bot~))

(free-var-huh ?(check-fv x ('Pi~ x T K)) ('bot~))
[(free-var-huh ?(check-fv x ('Pi~ y T K)) ('top~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x T) ('top~))
    (free-var-huh !(check-fv x K) ('top~))]
[(free-var-huh ?(check-fv x ('Pi~ y T K)) ('bot~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x T) ('bot~))]
[(free-var-huh ?(check-fv x ('Pi~ y T K)) ('bot~)) <--
    (=/= x y)
    (free-var-huh !(check-fv x K) ('bot~))]

[(free-var-huh ?(check-fv x (t-app T-func t-arg)) ('top~)) <--
    (free-var-huh !(check-fv x T-func) ('top~))
    (free-var-huh !(check-fv x t-arg) ('top~))]
[(free-var-huh ?(check-fv x (t-app T-func t-arg)) ('bot~)) <--
    (free-var-huh !(check-fv x T-func) ('bot~))]
[(free-var-huh ?(check-fv x (t-app T-func t-arg)) ('bot~)) <--
    (free-var-huh !(check-fv x t-arg) ('bot~))]

(free-var-huh ?(check-fv x ('star~)) ('bot~))
; free var for pi in kind is covered by free var for pi in type

; NOTE subst here is not capture avoiding
; substitution for term in kind
(subst-kind ?(do-subst-kind x t ('star~)) ('star~))
[(subst-kind
    ?(do-subst-kind x t
        ('Pi~ xk T K))
    ('Pi~ xk T-substed K-substed)) <--
    (subst-type !(do-subst-type x t T) T-substed)
    (subst-kind !(do-subst-kind x t K) K-substed)]
; substitution for term in type
(subst-type ?(do-subst-type x t (type T-name)) (type T-name))
[(subst-type
    ?(do-subst-type x t
        ('Pi~ T-arg T-Targ T-body))
    ('Pi~ T-arg T-Targ-substed T-body-substed)) <--
    (subst-type !(do-subst-type x t T-Targ) T-Targ-substed)
    (subst-type !(do-subst-type x t T-body) T-body-substed)]
[(subst-type
    ?(do-subst-type x t
        (t-app T-func t-arg))
    (t-app T-func-substed t-arg-substed)) <--
    (subst-type !(do-subst-type x t T-func) T-func-substed)
    (subst-term !(do-subst-term x t t-arg) t-arg-substed)]
; substitution for term in term
(subst-term ?(do-subst-term x t (var x)) t)
[(=/= x y) --> (subst-term ?(do-subst-term x t (var y)) (var y))]
;
[(subst-term ?(do-subst-term x t ('lambda~ arg T-arg body))
    ('lambda~ arg T-arg-substed body-substed)) <--
    (subst-term !(do-subst-term x t body) body-substed)
    (subst-type !(do-subst-type x t T-arg) T-arg-substed)]
[(subst-term ?(do-subst-term x t (app func arg))
    (app func-substed arg-substed)) <--
    (subst-term !(do-subst-term x t func) func-substed)
    (subst-term !(do-subst-term x t arg) arg-substed)]

; materialize & rename, make it reads better
[('mapsto~ x t K K-substed) <-- (subst-kind (do-subst-kind x t K) K-substed)]
[('mapsto~ x t T T-substed) <-- (subst-type (do-subst-type x t T) T-substed)]
[('mapsto~ x t t t-substed) <-- (subst-term (do-subst-term x t t) t-substed)]

; ---------------------------------------------
; proof checking algorithm

; ; strong normalization
; ; general β reduce
; ('Downarrow~ "beta-abs"
;     (premise1 ?('longrightarrow~-'beta~ t1 t2))
;     (conclusion ?('longrightarrow~-'beta~ ('lambda~ x S t1) 
;                        ('lambda~ x S t2))))
; ('Downarrow~ "beta-app1"
;     (premise1 ?('longrightarrow~-'beta~ t1 t2))
;     (conclusion ?('longrightarrow~-'beta~ (app t1 t) (app t2 t))))
; ('Downarrow~ "beta-app2"
;     (premise1 ?('longrightarrow~-'beta~ t1 t2))
;     (conclusion ?('longrightarrow~-'beta~ (app t t1) (app t t2))))
; ('Downarrow~ "beta-appabs"
;     ('mt~)
;     (conclusion ?('longrightarrow~-'beta~ (app ('lambda~ x T1 t1) t2))
;                        {'mapsto~ x t2 t1})))

; weak head reduction

; wh-appabs
('longrightarrow~-wh ?(wh-norm (app ('lambda~ x T1 t1) t2))
       {'mapsto~ x t2 t1})
[(wh-norm (app ('lambda~ x T1 t1) t2)) --> (do-subst-term x t2 t1)]
; wh-app1
[('longrightarrow~-wh ?(wh-norm (app t1 t2)) (app t1' t2)) <--
    ('longrightarrow~-wh !(wh-norm t1) t1')]

; top down checking? or we actually need bottom up checking?
; 'RightTeeVector~ means some term under some context is checked in LF system
; algorthmic kind formation Γ ⥛ K
; wfa-star
('RightTeeVector~ ?(LF-check 'Gamma~ ('star~)))
; wfa-pi
[('RightTeeVector~ !(LF-check 'Gamma~ (type-bind T ('star~))))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x T) 'Gamma~) K))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('Pi~ x T K)))]
; Algorithmic kinding Γ ⥛ T::K
; ka-var
[('in~ (type-bind T K) 'Gamma~)
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (type-bind T K)))]
; ka-pi
[('RightTeeVector~ !(LF-check 'Gamma~ (type-bind T1 ('star~))))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x T1) 'Gamma~) (type-bind T2 ('star~))))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (type-bind ('Pi~ x T1 T2) ('star~))))]
; ka-app
[('RightTeeVector~ (LF-check 'Gamma~ (type-bind S ('Pi~ x T1 K))))
 ('RightTeeVector~ (LF-check 'Gamma~ (term-bind t T2)))
 ('RightTeeVector~ (LF-check 'Gamma~ ('equiv~ T1 T2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (term-bind (t-app S t) {'mapsto~ x t K})))]
[(LF-check 'Gamma~ (term-bind (t-app S t) {'mapsto~ x t K}))
 ('equiv~ T1 T2)
 (term-bind t T2)
 ('Pi~ x T1 K)
    -->
    (LF-check 'Gamma~ (type-bind S ('Pi~ x T1 K)))
    (LF-check 'Gamma~ (term-bind t T2))
    (LF-check 'Gamma~ ('equiv~ T1 T2))]
; how do I issue subst here? stupid way is:
[(type-bind S ('Pi~ x T1 K)) (term-bind t T2)
 ('equiv~ T1 T2)
    -->
    (do-subst-kind x t K)]
; algorithmic typing Γ ⥛ t : T
; ta-var
[('in~ (term-bind x T) 'Gamma~)
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (term-bind x T)))]
; ta-abs
[('RightTeeVector~ !(LF-check 'Gamma~ (type-bind S ('star~))))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x S) 'Gamma~) (term-bind t T)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (term-bind ('lambda~ x S t) ('Pi~ x S T))))]
; ta-app
[('RightTeeVector~ (LF-check 'Gamma~ (term-bind t1 ('Pi~ x S1 T))))
 ('RightTeeVector~ (LF-check 'Gamma~ (term-bind t2 S2)))
 ('RightTeeVector~ (LF-check 'Gamma~ ('equiv~ S1 S2)))
    -->
    ('RightTeeVector~ (LF-check 'Gamma~ (term-bind (app t1 t2) {'mapsto~ x t2 T})))]
[(LF-check 'Gamma~ (term-bind (app t1 t2) {'mapsto~ x t2 T}))
 (term-bind t1 ('Pi~ x S1 T))
 (term-bind t2 S2)
 ('equiv~ S1 S2)
    -->
    (LF-check 'Gamma~ (term-bind t1 ('Pi~ x S1 T)))
    (LF-check 'Gamma~ (term-bind t2 S2))
    (LF-check 'Gamma~ ('equiv~ S1 S2))]
[(term-bind t1 ('Pi~ x S1 T)) (term-bind t2 S2)
 ('equiv~ S1 S2)
    -->
    (do-subst-type x t2 T)]

; alrogithmic kind equivalence Γ ⥛ K ≡ K'
; qka-star
('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ ('star~) ('star~))))
; qka-pi
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ T1 T2)))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x T1) 'Gamma~) ('equiv~ K1 K2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ ('Pi~ x T1 K1)
                        ('Pi~ x T2 K2))))]
; algorithmic type equivalence Γ ⥛ S ≡ T :: K
; qta-var
('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ X X)))
; qta-pi
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ S1 T1)))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x T1) 'Gamma~) ('equiv~ S2 T2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ ('Pi~ x S1 S2)
                        ('Pi~ x T1 T2))))]
; qta-app
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ S1 S2)))
 ('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ t1 t2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ (t-app S1 t1) (t-app S2 t2))))]
; algorithmic term equivalence Γ ⥛ t1 ≡ t2 : T
; qa-wh
[('equiv~ s t) --> (wh-norm s) (wh-norm t)]
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~-wh {'longrightarrow~-wh (wh-norm s)}
                        {'longrightarrow~-wh (wh-norm t)})))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ s t)))]
; qa-var
('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh x x)))
; qa-abs
[('RightTeeVector~ !(LF-check (ctx (term-bind x S) 'Gamma~) ('equiv~ t1 t2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh ('lambda~ x S t1)
                           ('lambda~ x S t2))))]
; qa-app
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~-wh s1 s2)))
 ('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~-wh t1 t2)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh (app s1 t1) (app s2 t2))))]
; qa-nabs1
[('RightTeeVector~ !(LF-check (ctx (term-bind x S) 'Gamma~) ('equiv~ (app s x) t)))
 (term-not-'lambda~ s)
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh s ('lambda~ x S t))))]
; qa-nabs2
[('RightTeeVector~ !(LF-check (ctx (term-bind x S) 'Gamma~) ('equiv~ s (app t x))))
 (term-not-'lambda~ t)
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh ('lambda~ x S s) t)))]


; ---------------------------------------------
; algorithmic type checking for CC

; beta reduction for all
[('longrightarrow~-wh ?(wh-norm (all x T t)) (all x T t')) <--
    ('longrightarrow~-wh !(wh-norm t) t')]

; ka-prop
('RightTeeVector~ ?(LF-check 'Gamma~ (type-bind (Prop) ('star~))))
; ka-prf
[('RightTeeVector~ !(LF-check 'Gamma~ (type-bind t (Prop))))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (type-bind (t-app (Prf) t)
                        ('star~))))]
; qt-all-e
[('RightTeeVector~ !(LF-check 'Gamma~ (type-bind T ('star~))))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x T) 'Gamma~) (type-bind t (Prop))))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ (term-bind (all x T t) (Prop))))]
; qka-pi-prf
[('longrightarrow~-wh !(wh-norm t) (all x T1 t2))
 ('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ S1 T1)))
 ('RightTeeVector~ !(LF-check (ctx (term-bind x S1) 'Gamma~) ('equiv~ S2 (t-app (Prf) t2))))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ ('Pi~ x S1 S2)
                        (t-app (Prf) t))))]
; qka-prf-pi
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ ('Pi~ x S1 S2)
                     (t-app (Prf) t))))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ (t-app (Prf) t)
                    ('Pi~ x S1 S2))))]
; qka-prf
[('RightTeeVector~ !(LF-check 'Gamma~ ('equiv~ s t)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~ (t-app (Prf) s)
                        (t-app (Prf) t))))]
; qa-all-e
[('RightTeeVector~ (LF-check 'Gamma~ ('equiv~ S1 T1)))
 ('RightTeeVector~ (LF-check (ctx (term-bind x S1) 'Gamma~) ('equiv~ s t)))
    -->
    ('RightTeeVector~ ?(LF-check 'Gamma~ ('equiv~-wh (all x S1 s)
                           (all x T1 t))))]
[(LF-check 'Gamma~ ('equiv~-wh (all x S1 s)
                   (all x T1 t)))
 ('equiv~ S1 T1)
 -->
    (LF-check (ctx (term-bind x S1) 'Gamma~) ('equiv~ s t))
    (LF-check (ctx (term-bind x S1) 'Gamma~) ('equiv~ s t))]


; ---------------------------------------------
; encode Nat theory in LF


; I use a macro expansion like helper rule 'macro~ to make proof term reads easier
; pretty print for "macro" is ⇻
; pretty print for §
('macro~ ?('expand~ (var x)) (var x))
[('macro~ ?('expand~ ('lambda~ x T s))
    ('lambda~ x T-expanded s-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)
    ('macro~ !('expand~ s) s-expanded)]
[('macro~ ?('expand~ (app func arg))
    (app func-expanded arg-expanded)) <--
    ('macro~ !('expand~ func) func-expanded)
    ('macro~ !('expand~ arg) arg-expanded)]
('macro~ ?('expand~ (type t)) (type t))
[('macro~ ?('expand~ ('Pi~ x T-arg T-body))
    ('Pi~ x T-arg-expanded T-body-expanded)) <--
    ('macro~ !('expand~ T-arg) T-arg-expanded)
    ('macro~ !('expand~ T-body) T-body-expanded)]
[('macro~ ?('expand~ (t-app func arg))
    (t-app func-expanded arg-expanded)) <--
    ('macro~ !('expand~ func) func-expanded)
    ('macro~ !('expand~ arg) arg-expanded)]
('macro~ ?('expand~ ('star~)) ('star~))
[('macro~ ?('expand~ (all x T t))
    (all x T-expanded t-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)
    ('macro~ !('expand~ t) t-expanded)]
('macro~ ?('expand~ (Prop)) (Prop))
('macro~ ?('expand~ (Prf)) (Prf))
[('macro~ ?('expand~ ('equiv~ x y))
    ('equiv~ x y)) <--
    ('macro~ !('expand~ x) x-expanded)
    ('macro~ !('expand~ y) y-expanded)]
[('macro~ ?('expand~ (term-bind x T))
    (term-bind x T-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)]
[('macro~ ?('expand~ (type-bind T K))
    (type-bind T K-expanded)) <--
    ('macro~ !('expand~ K) K-expanded)]

; use arrow to abbreviation
; 'longrightarrow~ A B = 'Pi~ x A B
[('macro~ ?('expand~ ('longrightarrow~ x A B))
    ('Pi~ x A-expanded B-expanded)) <--
    ('macro~ !('expand~ A) A-expanded)
    ('macro~ !('expand~ B) B-expanded)]
('macro~ ?('expand~ (Proof a)) (t-app (Prf) a))


; nat = all a: Prop.all z: Prf a.all s: (Prf a -> Prf a) . a
('macro~ ('expand~ ('nat~)) {'macro~ !('expand~ 
    (all "n-a" (Prop)
        (all "n-z" (Proof "n-a")
            (all "n-s" ('longrightarrow~ "n-x" (Proof "n-a") (Proof "n-a"))
                    (var "n-a")))))})
; (print-nat
;     (all "n-a" (Prop )
;         (all "n-z" (t-app (Prf ) "n-a")
;             (all "n-s" ('Pi~ "n-x" (t-app (Prf) "n-a") (t-app (Prf) "n-a"))
;                 (var "n-a")))))
; (print-nat {'macro~ ('expand~ ('nat~))})
; zero = (λa:Prop.λz:(Prf a).λ s: (Prf a -> Prf a).z) : Prf nat
('macro~ ('expand~ (zero)) {'macro~ !('expand~
    ('lambda~ "z-a" (Prop)
        ('lambda~ "z-z" (Proof "z-a")
            ('lambda~ "z-s" ('longrightarrow~ "z-x" (Proof "z-a") (Proof "z-a"))
                (var "z-z")))))})
; zero : Prf nat
(term-bind {'macro~ !('expand~ (zero))} (Proof ('nat~)))

; here we treat succ as a function
; succ = λn:Prf nat.λa:Prop. λz:Prf a.
;           λs:Prf a → Prf a.s(n a z s) : Prf nat → Prf nat
('macro~ ('expand~ (succ)) {'macro~ !('expand~
    ('lambda~ "s-n" (Proof ('nat~))
        ('lambda~ "s-a" (Prop)
            ('lambda~ "s-z" (Proof "s-a")
                ('lambda~ "s-s" ('longrightarrow~ "s-x" (Proof "s-a") (Proof "s-a"))
                    (app (var "s-s") (app (app (app (var "s-n") (var "s-a")) (var "s-z")) (var "s-s")))))))
       )})
('macro~ ('expand~ ?(Suc n)) {'macro~ !('expand~ (app (succ) n))})
(term-bind {'macro~ !('expand~ (succ))} ('longrightarrow~ "s-xp" (Proof ('nat~)) (Proof ('nat~))))

; (print-suc {'macro~ !('expand~ (Suc (zero)))})

(LF-check ('mt~)
    (term-bind {'macro~ !('expand~ (Suc (zero)))}
       (Proof ('nat~))))

