
; pure first order dependent type ('lambda~LF)
; based on advance topic in type and programming language
; Charpter 2.2

; term
; var
(var "x")
; abstraction
('lambda~ "x" (type "T") (var "x"))
; application
(app ('lambda~ "x" (var "x")) (var "y"))

; term helper predicate
(term-not-'lambda~ ?(var x))
(term-not-'lambda~ ?(app func arg))

; types
; type/family var
(type "T")
; dependent product type
('Pi~ "x" (type "T") (type "T"))
; type family application
(t-app (type "T") (var "x"))

; kind
; kind of proper type
('star~)
; kind of type family
('Pi~ "x" (type "T") ('star~))

; context
('mt~)
(ctx (term-bind "x" (type "T"))
    (ctx (type-bind (type "X") ('star~))
        ('mt~)))

; ---------------------------------------------
; typing rule helper functions

; predicate if binding is in an context
('in~ ?(ctx bind rest) bind)
[('in~ res bind1) --> ('in~ ?(ctx bind res) bind1)]

; NOTE subst here is not capture avoiding
; substitution for term in kind
(subst-kind ?(do-subst-kind x t ('star~)) ('star~))
[(subst-kind
    ?(do-subst-kind x t
        ('Pi~ xk T K))
    ('Pi~ xk T-substed K-substed)) <--
    (subst-type !(do-subst-type x t T) T-substed)
    (subst-kind !(do-subst-kind x t K) K-substed)]
; substitution for term in type
(subst-type ?(do-subst-type x t (type T-name)) (type T-name))
[(subst-type
    ?(do-subst-type x t
        ('Pi~ T-arg T-Targ T-body))
    ('Pi~ T-arg T-Targ-substed T-body-substed)) <--
    (subst-type !(do-subst-type x t T-Targ) T-Targ-substed)
    (subst-type !(do-subst-type x t T-body) T-body-substed)]
[(subst-type
    ?(do-subst-type x t
        (t-app T-func t-arg))
    (t-app T-func-substed t-arg-substed)) <--
    (subst-type !(do-subst-type x t T-func) T-func-substed)
    (subst-term !(do-subst-term x t t-arg) t-arg-substed)]
; substitution for term in term
(subst-term ?(do-subst-term x t (var x)) t)
[(=/= x y) --> (subst-term ?(do-subst-term x t (var y)) (var y))]
;
[(subst-term ?(do-subst-term x t ('lambda~ arg T-arg body))
    ('lambda~ arg T-arg-substed body-substed)) <--
    (subst-term !(do-subst-term x t body) body-substed)
    (subst-type !(do-subst-type x t T-arg) T-arg-substed)]
[(subst-term ?(do-subst-term x t (app func arg))
    (app func-substed arg-substed)) <--
    (subst-term !(do-subst-term x t func) func-substed)
    (subst-term !(do-subst-term x t arg) arg-substed)]

; materialize & rename, make it reads better
[('mapsto~ x t K K-substed) <-- (subst-kind (do-subst-kind x t K) K-substed)]
[('mapsto~ x t T T-substed) <-- (subst-type (do-subst-type x t T) T-substed)]
[('mapsto~ x t t t-substed) <-- (subst-term (do-subst-term x t t) t-substed)]

(wh-reducable ?(app ('lambda~ x T t1) t2))
(wh-reducable ?(app (app _ _) t2))

(wh-non-reducable ?(var x))
(wh-non-reducable ?('lambda~ x T t1))
(wh-non-reducable ?(all x T t))
(wh-non-reducable ?(app (var x) t2))
(wh-non-reducable ?(app (all x T t) t2))

; weak head reduction
; base case
[('longrightarrow~-wh ?(wh-norm t) t) <-- (wh-non-reducable t)]
; recursive case
[('longrightarrow~-wh (wh-norm t1) t2)
 (wh-non-reducable t2) -->
    (whnf t1 t2)]
[('longrightarrow~-wh ?(wh-norm (app t1 t2)) (app t1' t2)) <--
    ('longrightarrow~-wh !(wh-norm t1) t1')]
[(wh-norm (app ('lambda~ x T t1) t2)) --> (do-subst-term x t2 t1)]
('longrightarrow~-wh ?(wh-norm (app ('lambda~ x T t1) t2)) {'mapsto~ x t2 t1})
; transitive
[('longrightarrow~-wh (wh-norm t1) t2)
 ('longrightarrow~-wh (wh-norm t2) t3) -->
    ('longrightarrow~-wh (wh-norm t1) t3)]

; evaluate wh-normal form for every app
(wh-norm ?(app ('lambda~ x T1 t1) t2))
(wh-norm ?(app t1 t2))
(wh-norm ?(all x T t))

; ---------------------------------------------
; proof checking algorithm

; type inference
; "-infer" means some term **try** type (unchecked could be wrong),
; this rule will search all possible type for a term, based on
; algorithmic type checking rules.
; in inference stage, we use the observation from IncA paper, 
; decouple context creation and typing term creation

; populating context
[(top t) --> (term-in-ctx t ('mt~))]
[(term-in-ctx ('lambda~ x T t) 'Gamma~) -->
    (term-in-ctx t (ctx (term-bind x T) 'Gamma~))
    (term-in-ctx T 'Gamma~)]
[(term-in-ctx (app t1 t2) 'Gamma~) -->
    (term-in-ctx t1 'Gamma~)
    (term-in-ctx t2 'Gamma~)]
[(term-in-ctx ('Pi~ x T K) 'Gamma~) -->
    (term-in-ctx T 'Gamma~)
    (term-in-ctx K (ctx (type-bind x T) 'Gamma~))]
[(term-in-ctx (t-app T-func t-arg) 'Gamma~) -->
    (term-in-ctx T-func 'Gamma~)
    (term-in-ctx t-arg 'Gamma~)]
[(term-in-ctx (all x T t) 'Gamma~) -->
    (term-in-ctx t (ctx (term-bind x T) 'Gamma~))
    (term-in-ctx T 'Gamma~)]
; context for 'equiv~ and 'equiv~-wh
; seems these are not used anywhere
; [(term-in-ctx ('equiv~ t1 t2) 'Gamma~) -->
;     (term-in-ctx t1 'Gamma~)
;     (term-in-ctx t2 'Gamma~)]
; [(term-in-ctx ('equiv~-wh t1 t2) 'Gamma~) -->
;     (term-in-ctx t1 'Gamma~)
;     (term-in-ctx t2 'Gamma~)]
; [('equiv~-wh t1 t2)
;  (term-in-ctx t1 'Gamma~)
;  (term-in-ctx t2 'Gamma~) -->
;  (term-in-ctx ('equiv~-wh t1 t2) 'Gamma~)]
; [('equiv~ t1 t2)
;  (term-in-ctx t1 'Gamma~)
;  (term-in-ctx t2 'Gamma~) -->
;  (term-in-ctx ('equiv~ t1 t2) 'Gamma~)]

; Algorithmic kinding Γ ⥛ T::K
; ka-pi
[(type-bind T1 ('star~)) (type-bind T2 ('star~)) -->
    (type-bind ?('Pi~ x T1 T2) ('star~))]

; ka-app
; how do I issue subst here? stupid way is:
[(type-bind S ('Pi~ x T1 K)) --> ('equiv~-infer T1)]
[(type-bind S ('Pi~ x T1 K)) (term-bind t T2)
 ('equiv~ T1 T2)
    -->
    (do-subst-kind x t K)]
[(type-bind S ('Pi~ x T1 K)) 
 ('equiv~ T1 T2) --
 (term-bind t T2)
    -->
   (term-bind ?(t-app S t) {'mapsto~ x t K})]

; algorithmic typing Γ ⥛ t : T
; ta-var
[(term-in-ctx (var x) 'Gamma~)
 ('in~ 'Gamma~ (term-bind x T)) --> (term-bind ?(var x) T)]

; ta-abs
[(type-bind S ('star~)) (term-bind t T) --> (term-bind ?('lambda~ x S t) ('Pi~ x S T))]
; ta-app
[(term-bind t1 ('Pi~ x S1 T)) --> ('equiv~-infer S1)]
[(term-bind t1 ('Pi~ x S1 T)) (term-bind t2 S2)
 ('equiv~ S1 S2)
    -->
    (term-bind ?(app t1 t2) {'mapsto~ x t2 T})]
[(term-bind t1 ('Pi~ x S1 T)) (term-bind t2 S2)
 ('equiv~ S1 S2)
    -->
    (do-subst-type x t2 T)]

; alrogithmic kind equivalence Γ ⥛ K ≡ K'
; qka-star
('equiv~ ('star~) ('star~))
; qka-pi
[('equiv~-infer ('Pi~ x T1 K1)) --> ('equiv~-infer T1) ('equiv~-infer K1)]
[('equiv~-infer ('Pi~ x T1 K1))
 ('equiv~ T1 T2) ('equiv~ K1 K2)
    -->
    ('equiv~ ('Pi~ x T1 K1) ('Pi~ x T2 K2))]
; algorithmic type equivalence Γ ⥛ S ≡ T :: K
; qta-var
; (term-bind _ X) ?
[('equiv~-infer X) --> ('equiv~ X X)]

; qta-pi
[('equiv~-infer ('Pi~ x S1 S2)) --> ('equiv~-infer S1) ('equiv~-infer S2)]
[('equiv~-infer ('Pi~ x S1 S2))
 ('equiv~ S1 T1) ('equiv~ S2 T2)
    -->
    ('equiv~ ('Pi~ x S1 S2) ('Pi~ x T1 T2))]
; qta-app
[('equiv~-infer (t-app S1 t1)) --> ('equiv~-infer S1) ('equiv~-infer t1)]
[('equiv~-infer (t-app S1 t1))
 ('equiv~ S1 S2) ('equiv~ t1 t2)
    -->
    ('equiv~ (t-app S1 t1) (t-app S2 t2))]
; algorithmic term equivalence Γ ⥛ t1 ≡ t2 : T
; qa-wh
[('equiv~ s t) --> (wh-norm s) (wh-norm t)]
[('equiv~-infer s) --> ('equiv~-wh-infer {whnf s})]
[('equiv~-infer s) ('equiv~-wh {whnf s} {whnf t})
    -->
    ('equiv~ s t)]

; qa-var
[('equiv~-wh-infer x) --> ('equiv~-wh x x)]
; qa-abs
[('equiv~-wh-infer ('lambda~ x S t1)) --> ('equiv~-infer t1)]
[('equiv~-wh-infer ('lambda~ x S t1))
 ('equiv~ t1 t2)
    -->
    ('equiv~-wh ('lambda~ x S t1) ('lambda~ x S t2))]
; qa-app
[('equiv~-wh-infer (app s1 t1)) --> ('equiv~-wh-infer s1) ('equiv~-wh-infer t1)]
[('equiv~-wh-infer (app s1 t1))
 ('equiv~-wh s1 s2) ('equiv~-wh t1 t2)
    -->
    ('equiv~-wh (app s1 t1) (app s2 t2))]
; qa-nabs1
[('equiv~-wh-infer s) (term-not-'lambda~ s) --> ('equiv~-infer ?(app s (var x)))]
[('equiv~-wh-infer s) (term-not-'lambda~ s)
 ('equiv~ (app s (var x)) t)
 (term-in-ctx (ctx (term-bind x S) _) t) -->
    ('equiv~-wh s ('lambda~ x S t))]
; qa-nabs2
[('equiv~-wh-infer ('lambda~ x S s)) --> ('equiv~-infer s)]
[('equiv~-wh-infer ('lambda~ x S s)) (term-not-'lambda~ t)
 ('equiv~ s (app t (var x))) -->
    ('equiv~-wh ('lambda~ x S s) t)]

; ---------------------------------------------
; algorithmic type checking for CC
; ka-prop
(type-bind (Prop) ('star~))
(type-bind (Prf) ('Pi~ "prf-x" (Prop) ('star~)))
; ka-prf
[(term-bind t (Prop)) --> (type-bind ?(t-app (Prf) t) ('star~))]
; qt-all-e
[(type-bind T ('star~)) (term-bind t (Prop)) --> (term-bind ?(all x T t) (Prop))]
; qka-pi-prf
[('equiv~-infer ('Pi~ x S1 S2)) --> ('equiv~-infer S1) ('equiv~-infer S2)]
[('equiv~-infer ('Pi~ x S1 S2))
 ('equiv~ S1 T1) ('equiv~ S2 (t-app (Prf) t2)) --
 ('longrightarrow~-wh (wh-norm t) (all x T1 t2))
    -->
    ('equiv~ ('Pi~ x S1 S2) (t-app (Prf) t))]

; qka-prf-pi
[('equiv~ ('Pi~ x S1 S2) (t-app (Prf) t)) -->
    ('equiv~ (t-app (Prf) t) ('Pi~ x S1 S2))]
; qka-prf
[('equiv~-infer (t-app (Prf) s)) --> ('equiv~-infer s)]
[('equiv~-infer (t-app (Prf) s))
 ('equiv~ s t) -->
    ('equiv~ (t-app (Prf) s) (t-app (Prf) t))]
; qa-all-e
[('equiv~-wh-infer (all x S1 s)) --> ('equiv~-infer S1) ('equiv~-infer s)]
[('equiv~-wh-infer (all x S1 s))
 ('equiv~ S1 T1) ('equiv~ s t)
;  (ctx ((term-bind x S1) 'Gamma~) t)
  -->
    ('equiv~-wh (all x S1 s) (all x T1 t))]

; generate algorithmaic type judgement
[(LF-check 'Gamma~ ?(term-bind x T)) <-- (term-in-ctx 'Gamma~ t)]
[(LF-check 'Gamma~ ?(type-bind x T)) <-- (term-in-ctx 'Gamma~ t)]

; ---------------------------------------------
; encode Nat theory in LF

; I use a macro expansion like helper rule 'macro~ to make proof term reads easier
; pretty print for "macro" is ⇻
; pretty print for §
('macro~ ?('expand~ (var x)) (var x))
[('macro~ ?('expand~ ('lambda~ x T s))
    ('lambda~ x T-expanded s-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)
    ('macro~ !('expand~ s) s-expanded)]
[('macro~ ?('expand~ (app func arg))
    (app func-expanded arg-expanded)) <--
    ('macro~ !('expand~ func) func-expanded)
    ('macro~ !('expand~ arg) arg-expanded)]
('macro~ ?('expand~ (type t)) (type t))
[('macro~ ?('expand~ ('Pi~ x T-arg T-body))
    ('Pi~ x T-arg-expanded T-body-expanded)) <--
    ('macro~ !('expand~ T-arg) T-arg-expanded)
    ('macro~ !('expand~ T-body) T-body-expanded)]
[('macro~ ?('expand~ (t-app func arg))
    (t-app func-expanded arg-expanded)) <--
    ('macro~ !('expand~ func) func-expanded)
    ('macro~ !('expand~ arg) arg-expanded)]
('macro~ ?('expand~ ('star~)) ('star~))
[('macro~ ?('expand~ (all x T t))
    (all x T-expanded t-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)
    ('macro~ !('expand~ t) t-expanded)]
('macro~ ?('expand~ (Prop)) (Prop))
('macro~ ?('expand~ (Prf)) (Prf))
[('macro~ ?('expand~ ('equiv~ x y))
    ('equiv~ x y)) <--
    ('macro~ !('expand~ x) x-expanded)
    ('macro~ !('expand~ y) y-expanded)]
[('macro~ ?('expand~ (term-bind x T))
    (term-bind x-expanded T-expanded)) <--
    ('macro~ !('expand~ T) T-expanded)
    ('macro~ !('expand~ x) x-expanded)]
[('macro~ ?('expand~ (type-bind T K))
    (type-bind T-expanded K-expanded)) <--
    ('macro~ !('expand~ K) K-expanded)
    ('macro~ !('expand~ T) T-expanded)]

; use arrow to abbreviation
; 'longrightarrow~ A B = 'Pi~ x A B
[('macro~ ?('expand~ ('longrightarrow~ x A B))
    ('Pi~ x A-expanded B-expanded)) <--
    ('macro~ !('expand~ A) A-expanded)
    ('macro~ !('expand~ B) B-expanded)]
[('macro~ ?('expand~ (Proof a)) (t-app (Prf) a-expanded)) <--
    ('macro~ !('expand~ a) a-expanded)]

; expansion check
[(expansion-error t) <-- ('expand~ t) (~ 'macro~ ('expand~ t) _)]

[(term-in-ctx t _) (term-bind t _) --> (bounded-term t)]
[(term-in-ctx t _) (type-bind t _) --> (bounded-term t)]
[(type-error t) <-- (term-in-ctx t _) (~ bounded-term t)]

[('equiv~ t1 t2) (=/= t1 t2) --> (nonref-equiv t1 t2)]


[(define _ t) --> (top t)]

; nat = all a:Prop.all z:Prf a.all s:Prf a →Prf a. a
('macro~ ('expand~ ('nat~)) {'macro~ !('expand~ 
    (all "a" (Prop)
        (all "z" (Proof (var "a"))
            (all "s" ('longrightarrow~ "x" (Proof (var "a")) (Proof (var "a")))
                    (var "a")))))})
(define "nat" {'macro~ !('expand~ ('nat~))})

; zero = λa:Prop.λz:Prf a.λs:Prf a → Prf a.z : Prf nat
('macro~ ('expand~ (zero)) {'macro~ !('expand~
    ('lambda~ "a" (Prop)
        ('lambda~ "z" (Proof (var "a"))
            ('lambda~ "s" ('longrightarrow~ "x" (Proof (var "a")) (Proof (var "a")))
                (var "z")))))})
; zero : Prf nat
(define "zero" {'macro~ !('expand~ (zero))})
(print-zero-type {term-bind {define "zero"}})
  
; (print-zero-type
;     ('Pi~ "a" (Prop )
;         ('Pi~ "z" (t-app (Prf ) (var "a"))
;             ('Pi~ "s" ('Pi~ "x" (t-app (Prf) (var "a"))
;                         (t-app (Prf) (var "a")))
;                 (t-app (Prf ) (var "a"))))))
; (define "proof-nat"
;     (t-app (Prf )
;         (all "a" (Prop )
;             (all "z" (t-app (Prf ) (var "a"))
;                 (all "s" ('Pi~ "x" (t-app #11) (t-app #11))
;                     (var "a"))))))
(define "proof-nat" {'macro~ !('expand~ (Proof ('nat~)))})
; check if have generated proof request for (: zero ℕ)
('equiv~-infer {term-bind {'macro~ !('expand~ (zero))}})
(print-zero-type-equiv {'equiv~ {term-bind {define "zero"}}})
; zero is a proof of nat
(theorem "zero-is-proof-nat"
    ?('equiv~ {term-bind {'macro~ !('expand~ (zero))}}
        {'macro~ !('expand~ (Proof ('nat~)))}))

; here we treat succ as a function
; succ = λn:Prf nat.λa:Prop. λz:Prf a.
;           λs:Prf a → Prf a.s(n a z s) : Prf nat → Prf nat
('macro~ ('expand~ (succ)) {'macro~ !('expand~
    ('lambda~ "n" (Proof ('nat~))
        ('lambda~ "a" (Prop)
            ('lambda~ "z" (Proof (var "a"))
                ('lambda~ "s" ('longrightarrow~ "x" (Proof (var "a")) (Proof (var "a")))
                    (app (var "s")
                        (app (app (app (var "n") (var "a")) (var "z")) (var "s")))))))
       )})
; (LF-check ('mt~) {'macro~ !('expand~ (term-bind (succ) ('Pi~ "n" (Proof ('nat~)) (Proof ('nat~)))))})
[('macro~ ('expand~ ?(Suc n)) (app succ-expanded n-expanded)) <--
    ('macro~ !('expand~ (succ)) succ-expanded)
    ('macro~ !('expand~ n) n-expanded)]

; (print-suc {'macro~ !('expand~ (Suc (zero)))})
