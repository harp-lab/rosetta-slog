

('mt~)
('in~ ?(ctx x T res) x T)
[('in~ res x1 T1) --> ('in~ ?(ctx x T res) x1 T1)]

(all-context ('mt~))
(all-context ?(ctx x T res))

; first naive attempt at type checking
; unit
; (has-type {all-context} ?(true) (Bool))
; (has-type {all-context} ?(false) (Bool))
; [(has-type C ?(app e1 e2) T) <--
;     (has-type C e1 ('longrightarrow~ T1 T))
;     (has-type C e2 T1)]
; [(has-type (ctx x T1 Cp) ?('lambda~ x T1 b) ('longrightarrow~ T1 T2)) <--
;     (has-type Cp b T2)]
; [(has-type C ?(var x) T) <--
;     ('in~ C x T)]

(top (app ('lambda~ "x" (Bool) (var "x")) (true)))
(pass ?(has-type C (app ('lambda~ "x" (Bool) (var "x")) (true)) T))
; this proof search will fail, because just from bottom up, when system sees
; (var "x") it has no idea what context "x" is in, so it can't find a type for
; it.

; using co function transformation
; https://szabta89.github.io/publications/inca-typechecking.pdf
(can-have-type ?(true) (Bool))
(can-have-type ?(false) (Bool))
[(can-have-type ?(app e1 e2) T) <--
    (can-have-type e1 ('longrightarrow~ T1 T))
    (can-have-type e2 T1)]

[(can-have-type ?('lambda~ x T1 b) ('longrightarrow~ T1 T2)) <--
    (can-have-type b T2)]

[(can-have-type ?(var x) T) <--
    ('pi~-typed (var x) C)
    ('in~ C x T)]

[('pi~-typed e1 C) <-- ('pi~-typed (app e1 e2) C)]
[('pi~-typed e2 C) <-- ('pi~-typed (app e1 e2) C)]
[('pi~-typed b (ctx x T1 C)) <-- ('pi~-typed ('lambda~ x T1 b) C)]
[('pi~-typed e ('mt~)) <-- (top e)]

[('pi~-typed e C)
 (can-have-type e T)
 -->
 (checked ('vdash~ e T C))]

; assembly proof tree
[(= judegement ('vdash~ (true) T C))
 (checked judegement)
 -->
 (proof judegement (T-True) )]

[(= judegement ('vdash~ (false) T C))
 (checked judegement)
 -->
 (proof judegement (T-False))]

[(= judegement ('vdash~ (var x) T C))
 ('in~ C x T)
 (checked judegement)
 -->
 (proof judegement (T-Var))]

[(debug ) <-- ('vdash~ ('lambda~ x T1 b) ('longrightarrow~ T1 T2) C)]

[(= judegement ('vdash~ ('lambda~ x T1 b) ('longrightarrow~ T1 T2) C))
 (checked judegement)
 (proof ('vdash~ b T2 (ctx x T1 C)) pf-b)
 -->
 (proof judegement (T-Abs pf-b))]

[(= judegement ('vdash~ (app e1 e2) T C))
 (checked judegement)
 (proof ('vdash~ e1 ('longrightarrow~ T1 T) C) pf-e1)
 (proof ('vdash~ e2 T1 C) pf-e2)
 -->
 (proof judegement (T-App pf-e1 pf-e2))]

(found-proof {proof ('vdash~ (app ('lambda~ "x" (Bool) (var "x")) (true)) (Bool) ('mt~))})
